Matrix

    Ограничение времени	1 секунда
    Ограничение памяти	64.0 Мб
    Ввод	стандартный ввод или input.txt
    Вывод	стандартный вывод или output.txt

Условие

В этом задании вам необходимо реализовать шаблонный класс для работы с матрицами фиксированного размера. Последнее означает, что размеры матрицы должны передаваться в виде шаблонных параметров-целых чисел (non-type template parameters), и для конкретного объекта не могут быть изменены в течении работы программы. С одной стороны, это накладывает ограничения - размер матриц должен быть жестко задан на этапе компиляции и пользователь не имеет возможности его менять. Кроме того, изменения параметров матриц будут требовать повторной компиляции исходного кода, использующего эти матрицы. С другой стороны, так как размеры матрицы - константы времени компиляции, мы имеем возможность использовать нединамические массивы (что заметно ускоряет работу с матрицами), компилятор имеет больше возможностей для оптимизации кода, а неправильная работа с матрицами (умножение матриц неподходящих размеров, обращение неквадратных матриц и т.п.) будет детектироваться еще на этапе сборки программы, а не во время исполнения.

Детали реализации

Требуется реализовать шаблонный класс Matrix, принимающий в качестве шаблонных параметров тип хранимых элементов, число строк матрицы и число столбцов. Так как шаблонные параметры - это константы времени компиляции, элементы матрицы можно хранить в двумерном C-style массиве (std::array в этом задании пока запрещен). Это поле-массив должно быть публичным для корректной работы агрегатной инициализации.

Для работы с матрицей предлагается реализовать следующие методы:

RowsNumber() и ColumnsNumber(), возвращающие число строк и столбцов соответственно;
Операция () ("круглые скобки") для доступа к элементам матрицы и возможности их изменения (подумайте, почему не []);
Метод At, аналогичный предыдущему пункту, но бросающий исключение MatrixOutOfRange в случае выхода за границы матрицы;
Функцию GetTransposed(matrix), возвращающую транспонированную версию переданной матрицы;
Операции сложения, вычитания умножения матриц и их присваивающие версии. Обратите внимание, что эти операции применимы не к любым парам матриц!;
Операции умножения и деления на число (слева и справа), а также их присваивающие версии;
Операции сравнения на равенство и неравенство двух матриц одинакового размера;
Операции ввода из потока и вывода в поток.

Пример:

Matrix<int, 2, 3> a{{1, 2, 3}, {4, 5, 6}};
Matrix<int, 3, 2> b = GetTransposed(a);
// a + b      CE
a + a;     // Ok
// a * a      CE 
a * b;     // Ok
// a *= b  // CE - в матрицу a нельзя присвоить матрицу другого размера
b *= Matrix<int, 2, 2>{1, 2, 3, 4}; // Ok

std::cout << a;
1 2 3
4 5 6

Замечания.

Решение должно состоять из одного файла matrix.h

Помните о константных и неконстантных методах

"Бросить исключение типа E" значит - написать строку throw E{};. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.

Методы этого и дополнительного задания (ниже) необязательно реализовывать наиболее эффективным способом. В первую очередь проверяется правильность реализации.

Дополнительная часть (0.5 балла)

Для работы с квадратными матрицами есть множество методов не применимых к матрицам произвольного размера. Тем не менее так как размеры матриц известны заранее, мы можем на этапе компиляции проверять внутри них корректность размера.

Дополнительно реализуйте:

Функцию Transpose(matrix), который транспонирует исходную матрицу, изменяя ее (ясно, что транспонировать без изменения размера можно только квадратные матрицы);

Функцию Trace()

подсчет следа матрицы;

Функцию Determinant()

детерминант матрицы;

Функции GetInversed() и Inverse() для обращения матриц (первый метод возвращает обратную, а второй изменяет исходную матрицу).

При попытке обращения вырожденной матрицы необходимо бросать исключение MatrixIsDegenerateError.
